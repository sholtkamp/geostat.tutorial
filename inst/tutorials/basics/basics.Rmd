---
title: "Tutorial Geostatistik"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(dplyr)
library(learnr)
library(kableExtra)
library(geostat.tutorial)
knitr::opts_chunk$set(echo = FALSE)
```

## 1. Einführung
Willkommen zum R-Tutorial für den Kurs "Einführung in die Geostatistik". Dieses Tutorial dient dazu erste Schritte, wichtige Befehle und zentrale Konzepte von R zu vermitteln. Dieses Tutorial findet dabei in einer geschützten Umgebung statt, die auf dem Paket `learnr` basiert. Dadurch wird die Programmierumgebung von R in kleine Teile zerlegt und komplexere Funktionen zunächst verborgen.


### 1.1 R als Taschenrechner
Die R-Befehlszeile kann sowohl als Taschenrechner genutzt werden, als auch für komplexere Vorhaben. Simple Berechnungen wie z.B. `5 + 3` können mit Hilfe der Konsole leicht umgesetzt werden. Auch eine Verwendung von Variablen ist dabei möglich. Dazu wird der Zuweisungs-Operator `<-` genutzt um  Werte, Objekte oder Funktionen in einer Variablen zu speichern. 
<br>
Beispielsweise wird mit `a <- 5` einer Variablen `a` der Wert 5 zugewiesen. Sollte die Variable bereits existieren, wird sie durch diesen Befehl überschrieben, ansonsten wird sie neu erzeugt. Wird dann auch noch `b <- 3` genutzt, kann das simple Beispiel von oben auch mit  `a + b` berechnet werden und als Ergebnis wird `8` ausgegeben.
<br>
```{r info_1_1, echo = TRUE}
5 + 3

a <- 5
b <- 3
a + b
```
```{r ausprobierfeld, exercise=TRUE}
# Hier können Befehle ausprobiert werden!
```


### 1.2 Ausgaben in der R-Konsole
Bei der Ausgabe der vorherigen Berechnungen fallen 2 Dinge auf: Die Ausgabe beginnt mit <code>##</code> und darauf folgt <code>[1]</code>.
<br>
Die beiden Rauten haben keine tiefere Bedeutung und führen jeden Ausgabe in der Konsole an. Die Zahl in den eckigen Klammern hingegen gibt den führenden Index an. Ein Index ist eine Positionsangabe, wobei Index 1 in R immer für die vorderste oder erste Stelle steht. Betrachte zu Indizes das folgende Beispiel:
```{r info_1_2, echo = FALSE, include = TRUE}
vec_seq <- seq(from = 0, to = 3.5, by = 0.1)
vec_seq
```

Hier wird eine längere Zeichenfolge ausgegeben. Auch diese wird von Rauten und Zahlen in eckigen Klammern begleitet. Die Zahl <code>0.0</code> hat dabei den Index <code>1</code> und ist damit die erste Zahl der Folge. <code>1.9</code> den Index <code>20</code>, das heißt, dass sich `1.9` an der 20. Stelle der Folge befindet. Diese Indizes können in vielen Anwendungsfällen nützlich sein, wie z.B. zur Auswahl von Werten und bieten für alle anderen Fälle zumindest mehr Übersicht über die Ausgaben. 


### 1.3 Grundliegende Operatoren
Zum Rechnen bietet R eine Vielzahl vordefinierter, mathematischer Operationen und Funktionen. Die wichtigsten Funktionen für den Einstieg wurden in der folgenden Tabelle gesammelt. 
<br>
```{r info_1_3}
head <- c("Zeichen", "Funktion")

signs <- c("\\+", "\\-", "\\*", "/", "^", "%%",
           "<", ">", "<=", ">=", "==", "!=",
           "!", "&&", "||",
           "min(x)", "max(x)", "round(x, n)", "sum(x)", "sqrt(x)")

names <- c("Plus", "Minus", "Mal", "Geteilt", "Exponent", "Modulo",
           "Kleiner", "Größer", "Kleiner gleich", "Größer gleich", "Gleich", "Ungleich",
           "Logisch NOT", "Logisch AND", "Logisch OR",
           "Minimum von x", "Maximum von x", "Runden von x auf n Stellen", "Summe von x", "Wurzel von x")

table_df<- data.frame(signs, names)

colnames(table_df) <- head

kbl(table_df[], escape = FALSE) %>%
  kable_styling(bootstrap_options = c("striped", "hover")) %>%
  pack_rows("Arithmetische Operatoren", 1, 6) %>%
  pack_rows("Relationen", 7, 12) %>%
  pack_rows("Logik", 13, 15) %>%
  pack_rows("Mathematische Funktionen", 16, 20) 
```


### 1.4 Die Hilfefunktion
R bietet eine Hilfefunktion, um nähere Informationen über Funktionen zu erhalten. Ein Fragezeichen gefolgt von einer Funktion ruft die zugehörige Hilfeseite auf (z.B. <code>?sqrt</code> für die Wurzelfunktion <code>sqrt</code>). Die Beispiele am Ende der Datei sind oft am hilfreichsten. Die Hilfeseiten werden je nach Einstellung im Browser oder direkt in RStudio aufgerufen. <br>
Eine Suchfunktion für Funktionen wird mit <code>help.search("FUNKTIONSNAME")</code> auch angeboten. Diese funktioniert jedoch nur auf Englisch und ist nicht sehr einsteigerfreundlich. Eine normale Websuche, im Idealfall auf Englisch, ist für den Einstieg häufig die bessere Variante neue Funktionen zu finden.


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## \ \ \ \ Übung 1: Einführung
Führe folgende Rechnungen durch und weise sie jeweils den Variablen zu. Wie lässt sich die letzte Rechnung einfacher ausführen?
<br>

1.1) $\frac{5.1}{5+345}$
```{r 1_1, exercise=TRUE}
a <- 
a
```
```{r 1_1-hint-1}
"Um in R Kommazahlen zu benutzen muss ein . statt eines , verwendet werden."
```
```{r 1_1-hint-2}
# Befehl:
a <- 5.1 / (5 + 345)
a
```
```{r 1_1-solution}
# Ergebnis:
a = 0.01457143
```

1.2) $2⋅sin(90°)$
```{r 1_2, exercise=TRUE}
b <- 
b
```
```{r 1_2-hint-1}
"Die Sinusfunktion erwartet Eingaben im Bogenmaß."
```
```{r 1_2-hint-2}
"Winkel im Gradmaß können durch die Formel φRAD = φDEG * (π / 180) ins Bogenmaß umgerechnet werden"
```
```{r 1_2-hint-3}
# Befehl:
b <- 2 * sin(pi / 2)
b
```
```{r 1_2-solution}
# Ergebnis:
b = 2
```

1.3) $\sqrt(16) + \sqrt(25)$
```{r 1_3, exercise=TRUE}
c <- 
c
```
```{r 1_3-hint}
# Befehl:
c <- sqrt(16) + sqrt(25)
c
```
```{r 1_3-solution}
# Ergebnis:
c = 9
```

1.4) $\frac{\frac{5}{5+345} + {2⋅sin(90°)}}{\sqrt(16) + \sqrt(25)}$
```{r 1_4_setup}
a <- 5.1 / (5 + 345)
b <- 2 * sin(pi / 2)
c <- sqrt(16) + sqrt(25)
```
```{r 1_4, exercise=TRUE, exercise.setup = "1d_setup"}
d <- 
d
```
```{r 1_4-hint-1}
"Die Variablen aus vorherigen Aufgaben stehen noch zur Verfügung."
```
```{r 1_4-hint-2}
# Befehl:
d <- ((5.1 / (5 + 345)) + (2 * sin(pi / 2))) / (sqrt(16) + sqrt(25)) 
# ist das Gleiche wie 
d <- (a + b) / c
d
```
```{r 1_4-solution}
# Ergebis:
d = 0.2238413
```


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## 2. Datentpyen und -strukturen
R dient in den meisten Anwendungsfällen zur statistischen Analyse von Daten. Diese Daten werden in der Programmierumgebung in sogenannten Datenstrukturen gespeichert. R unterstützt eine Vielzahl von vorgefertigten Datenstrukturen. Um mit diesen arbeiten zu können, ist es nötig sowohl Datentypen, als auch die Datentrukturen selbst grundsätzlich zu verstehen.


### Datentypen
In R können viele verschiedene Datentypen genutzt und auch eigene definiert werden. Für diese Veranstaltung werden jedoch nur wenige davon benötigt. Diese sind grob gesagt Worte, Zahlen und Wahrheitswerte. Formal genau formuliert werden die folgenden Datentypen benutzt:
<ul>
  <li>`character`:
    <br> 
   Zeichen, wie Buchstaben, Wörter und Satzzeichen.
  </li>
  
  <li>`numeric`:
    <br> 
    Zahlen, umfasst `integer` (ganze Zahlen) und `double` (relle Zahlen).
  </li>

  <li>`logical`:
    <br> 
    Wahr (`TRUE`,`t`) oder Falsch (`FALSE`,`f`). Diese Werte werden auch als `Booleans` bezeichnet.
  </li>
  
  <li>`NA`:
    <br> 
    NA Werte sind nicht vorhandene Werte. Diese stammen oft aus Fehlern in den Daten oder falschen Berechnungen.
  </li>
</ul>
<br>

Um den Typen einer Variablen oder eines Wertes herauszufinden wird die Funktion `typeof(x)` benutzt. Diese Funktion ist vor allem dann wichtig, wenn man mehrere Werte zusammenfassen will.
<br>
Damit Variablen bei ihrer Erstellung den richtigen Datentypen haben, müssen bestimmte Konventionen eingehalten werden. Diese Konventionen werden im folgenden Beispiel gezeigt.
```{r info_2.0, include = TRUE, echo = TRUE}
# Numeric
ex_int <- 42 # Keine Dezimalzeichen
ex_double <- 1.99 # Double wird mit "." als Dezimalzeichen erzeugt

# Logical
ex_bool_t <- TRUE # Logische Werte werden komplett in Großbuchstaben geschrieben
ex_bool_f <- FALSE

# Character
ex_char <- "hello, world!" # Characters benötigen am Anfang und Ende Anführungszeichen

# NA
ex_na <- NA # NA wird komplett großgeschrieben
```


### Datenstrukturen
Mit diesen Datentypen als Grundlage können nun die Datenstrukturen betrachetet werden. Diese Grundlage ist notwendig, da die Datenstrukturen sich in zwei Gruppen einteilen lassen. Die Unterscheidung ist dabei, mit wie vielen Datentypen gleichzeitig sie kompatibel sind. Die Unterteilung der Datenstrukturen wird in der folgenden Abbildung dargestellt.
<br><br>

```{r img_2_0}
knitr::include_graphics("images/hopr_0306.png")
"Source: https://rstudio-education.github.io/hopr/images/hopr_0306.png"
```
<br>
Wie hier zu sehen ist, können Vektoren, Matritzen und Arrays nur einen Datentypen gleichzeitig beinhalten. Dies führt dazu, dass R Typkonvertierungen durchführt, wenn man mehr als einen Datentypen zur Erzeugung nutzt. Erzeugt man beispielweise eine Vektor aus Zahlen (integer/double) und Wörtern (character) werden die Zahlen in Wörter umgewandelt. Dabei handelt es sich um eine häufige Fehlerquelle wenn man beginnt mit R zu arbeiten.
<br>
In den folgenden Unterkapiteln werden diese Strukturen erklärt und Funktionen für den Umgang mit ihnen erläutert. Insbesondere Vektoren und Dataframes sind dabei von Bedeutung für die Übungen zu dieser Vorlesung. 


## \ \ \ \ 2.1 Vektoren
Vektoren sind eine dimensionslose Datenstruktur.Das heißt sie können genutzt werden, um Zahlenreihen oder auch Folgen von Begriffen zu speichern haben aber statt einer Dimension lediglich eine Länge. Dabei können beliebig viele Elemente des selben Datentyps in einem Objekt gespeichert werden. Um einen Vektor zu erzeugen wird die Funktion `c()` [d.h. combine, kombiniere] benutzt. So kann zum Beispiel der Vektor `(1, 2, 3)` (hier also eine Zahlenreihe mit den Zahlen 1, 2 und 3) mit Hilfe von `c(1, 2, 3)` erzeugt werden. Dieser kann dann mit `a <- c(1, 2, 3)` der Variablen `a` zugewiesen werden.

Beispiele für Vektoren können wie folgt aussehen:
```{r info_2_1_erstes, echo = TRUE}
# Erzeuge das Temperaturbeispiel als Vektor
temps <- c(25, 24.5, 25, 25.5, 26)

# Teste um welchen Datentypen es sich handelt
typeof(temps)
```
Der Befehl <code>temp <- c(25, 24.5, 25, 25.5, 26)</code> erzeugt einen Vektor der zunächst nur eine Reihe von Zahlen beinhaltet. Durch Interpretation können diese Zahlen jedoch mehr Inhalt bekommen, wie z.B. verschiedene Temperaturen einer Messstation, oder die Temperaturen aller Messtationen in einem Gebiet zu einer bestimmten Zeit. Um diese Interpretation zu erleichtern macht es Sinn, Variablen Namen zu geben, die für sich selbst sprechen. Dieser Vektor funktioniert so wie man es erwartet, d.h. mit den Temperaturzahlen kann normal gerechnet werden.

```{r info_2_1_zweites, echo = TRUE}
#!!! Achtung: Negativbeispiel !!!
# Erzeuge eine Beispielperson als Vektor
versuchsperson_1 <- c("Mia", "Musterfrau", 25, 1.65, 5)

# Teste um welchen Datentypen es sich handelt
typeof(versuchsperson_1)
```
Die Beschreibung eines Menschen durch <code>versuchsperson_1 <- c("Mia", "Musterfrau", 25, 1.75, 5)</code> ist auch ein Vektor. Hier sind die Datentypen jedoch gemischt. `"Mia"` und `"Musterfrau"` sind vom Typen character, `25` und `5` sind integers und `1.75` ist ein double. Da jedoch verschiedene Datentypen in einem Vektor nicht gemischt werden können, führt R eine Typkonvertierung durch. Das heißt, dass in diesem Beispiel alle Werte in characters umgewandelt werden. Es ist also nicht möglich mit dem Alter oder der Körpergröße dieser Beispielperson zu rechnen, da diese als Wörter verstanden werden.
<br>

Bei der Verwendung von characters sind Anführungsstriche sind nötig, um R deutlich zu machen, dass es sich um Zeichenketten und nicht etwa um Variablennamen handelt. So würde Konsole (ohne \"\") als Verweis auf ein Objekt mit dem Namen <code>Konsole</code> verstanden werden (siehe unten). 
```{r info_2_1_drittes, exercise=TRUE}
b <- c("hallo", Konsole)
b
```


### 2.1.1 Sequenzen und Widerholungen
Im Umgang mit R kommen bestimmte Vektoren immer wieder vor. Besonders häufig benötigt werden dabie Vektoren mit speziellen Zahlensequenzen, welche sich in R einfach erzeugen lassen. Hierzu stehen die Funktionen `seq()` und `rep()` zur Verfügung. 

Die Funktion `seq(from, to, by, length.out, ...)` dient dazu eine regelmäßige Zahlenfolge zu erzeugen. Drei der Parameter müssen angegeben werden und der 4. Wert, normalerweise `length.out`, kann dann automatisch berechnet werden: <br>
<ul>
<li>`from`: Anfangswert der Sequenz</li>
<li>`to`: Endwert der Sequenz</li>
<li>`by`: Differenz aufeinander folgender Zahlen</li>
<li>`length.out`: Insgesamte Anzahl der Elemente der Sequenz</li>
</ul>
Häufig findet man zur Erzeugung von Sequenzen auch die Kurzform `c(x : y)`. Diese ist gleichbedeutend mit `seq(from = x, to = y, by = 1)`.
<br>
<br>

Die Funktion `rep(x, times)` dient dazu einen Vektor oder Wert beliebig oft zu wiederholen. Dazu werden die folgenden Parameter benötigt: <br>
<ul>
<li>`x`: Vektor oder Faktor der wiederholt werden soll</li>
<li>`times`: Anzahl der Wiederholungen</li>
</ul>


### 2.1.2 Selektion in Vektoren
Um die Daten, die in einem Vektor gespeichert wurden zu benutzen, benötigt man Selektionsfunktionen. Dabei steht eine Vielzahl von Möglichkeiten zur Verfügung. Hier sind einige Besipiele für für Selektionen in Vektoren, `x` ist dabei der Vektor, `Index_1` und `Index_2` integers, `y` eine beliebige Zahl.
<ul>
<li>`x[Index]`: Gibt das Element des Vektors an Stelle <code>Index</code> aus</li>
<li>`x[-Index]`: Gibt alle Elemente des Vektors außer dem an Stelle <code>Index</code> aus</li>
<li>`x[Index_1 : Index_2]`: Gibt die Elemente des Vektors von <code>Index_1</code> bis <code>Index_2</code> aus</li>
<li>`x[c(Index_1, Index_2)]`: Gibt die Elemente des Vektors an den Stellen <code>Index_1</code> und <code>Index_2</code> aus</li>
<li>`x[x == y]`: Gibt die Elemente des Vektors aus, die gleich y sind</li>
<li>`x[x < y]`: Gibt die Elemente des Vektors aus, die kleiner als y sind</li>
</ul>


### 2.1.3 Vektorfunktionen
Neben der Selektion verfügen Vektroen über eine Vielzahl von Funktionen zur Manipulation. Im Folgenden werden die häufigsten dieser Funktionen aufgeführt. <code>x</code> bezeichnet dabei auch hier immer einen Vektor.
<ul>
<li>`length(x)`: Gibt die Länge eines Vektors, bzw. die Anzahl seiner Elemente aus</li>
<li>`sort(x)`: Gibt den Vektor mit sortierten Werten zurück</li>
<li>`rev(x)`: Gibt den Vektor in umgekehrter Reihenfolge zurück</li>
<li>`table(x)`: Gibt die Häufigkeiten der Werte innerhalb des Vektors zurück</li>
<li>`unique(x)`: Gibt die Anzahl der einzigartigen Werte im Vektor zurück</li>
<li>`x[Index] <- y`: Ersetzt den Wert des Vektors an Stelle <code>Index</code> durch y</li>
</ul>


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## \ \ \ \ \ \ \ \ \ \ Übung 2: Vektoren
2.1) Erzeuge einen Vektor von 0 bis 1 in 0,1-Schritten `(0, 0.1, 0.2, ..., 1)`.
```{r 2_1, exercise=TRUE}
vec_seq <- 
vec_seq
```
```{r 2_1-hint}
"Nutze die Hilfefunktion mit ?seq"
```
```{r 2_1-solution}
vec_seq <- seq(from = 0, to = 1, by = 0.1)
vec_seq
```

2.2) Erzeuge den Vektor `(1, 1, 1, 1, 1, 5, 5, 5)`.
```{r 2_2, exercise=TRUE}
vec_rep <- 
vec_rep
```
```{r 2_2-hint}
"Nutze die Hilfefunktion mit ?rep"
```
```{r 2_2-solution}
vec_rep <- rep(c(1, 5), times = c(5, 3))
vec_rep
```

2.3) Verwende den ersten Vektor und erzeuge durch Addieren und Multiplizieren die folgenden beiden Vektoren: `(1, 1.1, 1.2, ..., 2)` und `(2, 2.2, 2.4, ..., 4)`. Der Vektoren aus 2.1 steht dabei zur Verfügung.
```{r 2_3_setup}
vec_seq <- seq(from = 0, to = 1, by = 0.1)
```
```{r 2_3, exercise=TRUE, exercise.setup = "2c_setup"}
vec_1 <- 

vec_2 <- 
  
vec_1
vec_2
```
```{r 2_3-hint}
"Die Variablen aus vorherigen Aufgaben stehen noch zur Verfügung."
```
```{r 2_3-solution}
# Addierter Vektor
vec_1 <- vec_seq + 1

# Multiplizierter Vektor
vec_2 <- 2 * (vec_seq + 1)
  
# Ausgabe der Vektoren
vec_1
vec_2
```

2.4) Führe die Befehle `c(1, 3, 7) * c(5, 8, 2)` und `c(1, 3, 7) %*% c(5, 8, 2)` aus. Was ist an den Berechnungen in R speziell verglichen mit den Vektorrechnungen in der Mathematik?
```{r 2_4, exercise=TRUE}
command_1 <- c(1, 3, 7) * c(5, 8, 2) 
command_2 <- c(1, 3, 7) %*% c(5, 8, 2)

command_1
command_2
```
```{r 2_4_q}
quiz(caption = "\ ",
     
  question("Welche Art der Multiplikation wird mit dem Operator * ausgeführt?",
    answer("Matrixmultiplikation"),
    answer("Elementweise Multiplikation", correct = TRUE),
    answer("Skalare Multiplikation")
  ),
  question("Welche Art der Multiplikation wird mit dem Operator %*% ausgeführt?",
    answer("Matrixmultiplikation", correct = TRUE),
    answer("Elementweise Multiplikation"),
    answer("Skalare Multiplikation")
  )
)
```
<details>
<summary>Erklärung: (Klick mich!)</summary>

Durch Ausführen der normalen Multiplikation `*` werden zwei Vektoren elementweise multipliziert, das Ergebnis ist also wieder ein Vektor gleicher Länge. 
<br>
Der Matrixmultiplikationsoperator `%*%` führt in diesem Beispiel das Skalarprodukt aus, bildet also die elementweisen Produkte und summiert diese anschließend. Dies ist hier mathematisch nicht äquivalent, da eigentlich der erste Vektor als Zeilenvektor und der zweite Vektor als Spaltenvektor transponiert werden müsste, um das Skalarprodukt als Matrixmultiplikation zu interpretieren.
</details>
<br>

2.5) Weise einer Variablen den `x` Wert `12` zu und erstelle einen Vektor `vec` mit den Werten `1, 2, 3, 10, 100`. Multipliziere beide miteinander und speichere das Ergebnis als Variable z. Welche Art von Multiplikation wurde hier durchgeführt?
```{r 2_5, exercise=TRUE}
x <- 
vec <- 

z <- 
z
```
```{r 2_5-hint}
# Befehle:
x <- 12
vec <- c(1, 2, 3, 10, 100)

z <- x * vec
```
```{r 2_5-solution}
# Ergebnis: 
z = c(12, 24, 36, 120, 1200)
```
```{r 2_5_q}
quiz(caption = "\ ",
     
  question("Welche Art der Multiplikation wurde hier ausgeführt?",
    answer("Matrixmultiplikation"),
    answer("Skalare Multiplikation", correct = TRUE),
    answer("Elementweise Multiplikation")
  )
)
```
2.6) Mit welchen Befehlen kann der Wert <code>8</code> im Vektor <code>vec <- c(2, 3, 4, 7, 8, 15, 16, 23, 42)</code> selektiert werden? 
```{r 2_6_setup}
vec <- c(2, 3, 4, 7, 8, 15, 16, 23, 42)
```
```{r 2_6, exercise=TRUE, exercise.setup = "2_6_setup"}
# Hier können Befehle getestet werden. "vec" ist vordefiniert.
vec

```
```{r 2_6_q, echo=FALSE}
question("Mit welchen Befehlen kann der Wert <code>8</code> selektiert werden?",
  answer("vec[5]", correct = TRUE),
  answer("vec[8]"),
  answer("vec[vec = 8]"),
  answer("vec[vec == 8]", correct = TRUE),
  answer("vec[vec < 9]"),
  answer("vec[vec > 7]"),
  answer("vec[vec < 7]"),
  answer("vec[vec > 9]"),
  answer("vec[vec < 9 & vec > 7]", correct = TRUE)
)
```


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## \ \ \ \ 2.2 Matrizen
Matrizen können als erweiterte Vektoren mit besonderen Eigenschaften angesehen werden. Dabei unterscheiden sich von diesen durch ihr Dimensions-Attribut `dim`. Während Vektoren dimensionslos sind, sind Matrizen grundsätzlich zweidimensional. 
<br>
Um in R einen Vektor in eine Matrix umzuwandeln, muss durch die Parameter `nrow` [d.h. number of rows, Anzahl der Zeilen] bzw. `ncol` [d.h. number of columns, Anzahl der Spalten] angegeben werden, wie viele Zeilen und Spalten die Matrix haben soll. Dabei reicht es, einen der beiden Parameter anzugeben. Standardmäßig werden Matrizen spaltenweise mit den Elementen des Vektors gefüllt. Das heißt, dass die ersten 3 Zahlen im unteren Beispiel der ersten Spalte entsprechen. Um dies zu ändern muss der Parameter `byrow` auf `TRUE` gesetzt werden. 
<br>
Einzelne Elemente der Matrix können durch eckige Klammern gelesen und verändert werden. Dabei ist die erste Zahl immer die Zeilennummer, die zweite Zahl die Spaltennummer. Die oberste linke Zahl ist selektierbar mit `Matrixname[1,1]`. 


### 2.2.1 Erzeugung
```{r info_2_2_1, include = TRUE, echo = TRUE}
# Erzeugung einer Matrix mit neuen Werten
mat <- matrix(1:6, nrow = 3)
mat


# Erzeugung einer Matrix aus einem Vektor
vec <- c(1:6)
mat_2 <- matrix(vec, nrow = 3)
mat_2

# Erzeugung einer reihenweise befüllten Matrix
mat_row <- matrix(1:6, nrow = 3, byrow = TRUE)
mat_row
```


### 2.2.2 Dimensionen
```{r info_2_2_2, include = TRUE, echo = TRUE}
# Vektor aus Aufgabe 2.1
vec <- seq(from = 0, to = 1, by = 0.1)
vec

# Dimensionen von vec
dim(vec)


# Beliebige Matrix
mat <- matrix(1:6, nrow = 3, ncol = 2)
mat

# Dimension von mat
dim(mat)
```
<b>Randnotiz</b>:
<br> 
Die Ausgabe <code>NULL</code> des Befehls <code>dim(vec)</code> ist nicht gleichzusetzen mit 0. Stattdessen bedeutet <code>NULL</code>, dass der Rückgabewert nicht definiert ist. Die Ausgabe <code>## [1] 3 2</code> hingegen kann interpretiert werden als zweidmensionale Datenstruktur oder "Eine Matrix mit 3 Zeilen und 2 Spalten".


### 2.2.3 Selektion
Auch für die Selektion in Matrizen stehen viele Möglichkeiten zur Verfügung. Einige davon sind jedoch deutlich komplexer als für die hier angestrebten Ziele notwendig. In diesen Fällen bietet es sich an die Matrizen in Dataframes umzuwandeln, dazu später mehr. An dieser Stelle sollen jedoch die häufigsten Möglichkeiten zur Selektion in Matrizen genannt werden.
<br>
<ul>
<li>`x[Index_1, Index_2]`: Gibt das Element des Vektors an Stelle <code>(Index_1, Index_2)</code> zurück</li>
<li>`x[y, ]`: Selektiert die Zeile <code>y</code></li>
<li>`x[ , z]`: Selektiert die Spalte <code>z</code></li>
<li>`x[y:z, ]`: Selektiert die Zeilen <code>y</code> bis <code>z</code></li>
<li>`x[ , y:z]`: Selektiert die Spalten <code>y</code> bis <code>z</code></li>
</ul>

```{r info_2_2_3, include = TRUE, echo = TRUE}
mat <- matrix(1:6, nrow = 3, ncol =2)
mat

# Selektion des Wertes an Stelle Zeile 1, Spalte 2
mat[1, 2]

# Ändern des Wertes an Stelle Zeile 3, Spalte 1 auf 7
mat[3, 1] <- 7
```


### 2.2.4 Transponieren
Eine Matrix kann in R mit dem Befehl <code>t(Matrixname)</code> transponiert werden.
```{r info 2_2_4, echo = TRUE}
mat <- matrix(1:6, nrow = 3, ncol = 2)
mat
mat <- t(mat)
mat
```


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## \ \ \ \ \ \ \ \ \ \ Übung 3: Matrizen

3.1) Erzeuge nun selbst eine Matrix mit Zahlen von 1 bis 12, die drei Spalten hat (beginnend mit 1 2 3 in der ersten Zeile).
```{r 3_1, exercise=TRUE}
mat <- 
mat
```
```{r 3_1-hint}
"Nutze die Hilfefunktion mit ?matrix"
```
```{r 3_1-solution}
mat <- matrix(seq(1, 12, by = 1), nrow = 4, ncol = 3, byrow = TRUE)
mat
```

3.2) Ersetze nun die Zahl 6 in der Matrix durch die Zahl 15.
```{r 3_2_setup}
mat <- matrix(seq(1, 12, by = 1), nrow = 4, ncol = 3, byrow = TRUE)
```
```{r 3_2, exercise=TRUE, exercise.setup = "3e_setup"}
# Die notwendige Matrix ist vordefiniert
mat 
```
```{r 3_2-hint-1}
"Die Variablen aus vorherigen Aufgaben stehen noch zur Verfügung."
```
```{r 3_2-hint-2}
"Zum Austauschen muss zunächst die korrekte Stelle gewählt werden und dann eine Zuweisung ausgeführt werden."
```
```{r 3_2-hint-3}
"Beachte bei der Auswahl die Reihenfolge der Indizes."
```
```{r 3_2-solution}
mat[2, 3] <- 15
mat
```

3.3) Multipliziere die entstandene Matrix nun mit 4. Welche Veränderung kann in der Matrix beobachtet werden?
```{r 3_3_setup}
mat <- matrix(seq(1, 12, by = 1), nrow = 4, ncol = 3, byrow = TRUE)
```
```{r 3_3, exercise=TRUE, exercise.setup = "3e_setup"}
# Die notwendige Matrix ist vordefiniert
mat
```
```{r 3_3_q, echo=FALSE}
quiz(caption = "\ ",
  question("Welche Veränderung kann in der Matrix beobachtet werden",
    answer("Nur das Element an Stelle [1, 1] ist vervierfacht."),
    answer("Alle Elemente sind vervierfacht.", correct = TRUE),
    answer("Keines der Elemente ist vervierfacht."),
    random_answer_order = TRUE
  )
)
```


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## \ \ \ \ 2.3 Arrays
Arrays können als Erweiterung von Matrizen betrachtet werden. Die Dimensionen von Arrays werden nicht mit `nrow` bzw. `ncol` bestimmt, sondern direkt über den Parameter `dim`. Dabei können Arrays beliebig viele Dimensionen haben.
<br>
Um die Dimensionen zu bestimmen, wird ein Vektor genutzt. Jede Stelle des Vektors entspricht einer Dimension. Der Wert an der Stelle bestimmt die Tiefe einer Dimension. Im folgenden Beispiel wird ein Array erzeugt, das insgesamt `(2 * 2 * 3) = 12` Einträge fassen kann. 


### 2.3.1 Erzeugung und Selektion
Das Erzeugen von Arrays funktioniert ähnlich wie bei Matrizen, mit dem Unterschied, dass statt `nrow` und `ncol` das Argument `dim` übergeben wird. Die Selektion funktioniert analog, benötigt jedoch mehr Argumente in Abhängigkeit von der Dimension des Arrays.
```{r 2.3_a, include = TRUE, echo = TRUE}
arr <- array(1:12, dim = c(2, 2, 3))
arr

# Dimensionen von arr
dim(arr)

# Selektion des Wertes an Stelle [1, 2, 3], also 1. Zeile, 2. Spalte, 3. "Schicht"
arr[1, 2, 3]
```


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## \ \ \ \ 2.4 Listen 
Listen können in R dazu genutzt werden, mehrere Elemente wie Vektoren und Matrizen zu einem Objekt zusammenzufassen, oder simple Gruppierungen mit verschiedenen Datentypen anzulegen. Erzeugt werden sie mit dem Befehl `list(x, y, ...)`. Dadurch wird aus den Objekten x, y und ggf. weiteren Objekten (...), eine Liste erzeugt. Listen können mit oder ohne Namen für ihre Bestandteile erzeugt werden. Betrachte dazu das folgende Beispiel:
```{r, echo = TRUE}
# Erzeuge Besipieldaten
vec_1 <- c(1, 2, 3, 4, 5)
vec_2 <- c("eins", "zwei", "drei", "vier", "fünf")

# Fasse Beispieldaten zu einer Liste zusammen
unnamed_list <- list(vec_1, vec_2)

# Betrachte die Namen der Objekte in der Liste
names(unnamed_list)


# Fasse die Beispieldaten zu einer Liste mit Namen zusammen
named_list <- list(zahlen = vec_1, woerter = vec_2)

# Betrachte die Namen 
names(named_list)
```


### 2.4.1 Selektion in Listen
Um auf die Daten innerhalb einer Liste zuzugreifen wird eine ähnliche Notation verwendet wie bei Vektoren, Matrizen und Arrays, d.h. es werden eckige Klammern genutzt. Sollten die Listenelemente über Namen verfügen, besteht jedoch auch die Möglichkeit zur Adressierung durch `$NAME`. Außerdem kann man auch direkt auf die einzelnen Elemente der Objekte in der Liste zugreifen.
```{r, echo = TRUE}
# Erzeuge Besipieldaten
vec_1 <- c(1, 2, 3, 4, 5)
vec_2 <- c("eins", "zwei", "drei", "vier", "fünf")

# Fasse die Beispieldaten zu einer Liste mit Namen zusammen
named_list <- list(zahlen = vec_1, woerter = vec_2)

# Greife auf vec_1 zu
vec_1_brackets <- named_list[[1]]
vec_1_names <- named_list$zahlen

# Greife auf vec_2 zu
vec_2_brackets <- named_list[[2]]


# Greife auf das dritte Element von vec_1 zu
vec_1_3_brackets <- named_list[[1]][3]
vec_1_3_names <- named_list$zahlen[3]


# Zeige, das beide Zugriffsarten das gleiche Ergebnis liefern
all.equal(vec_1_brackets, vec_1_names)
all.equal(vec_1_3_brackets, vec_1_3_names)
```


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## \ \ \ \ 2.5 Dataframes
Dataframes sind die häufigste Methode um in R größere Mengen an Daten systematisch zu speichern. Dataframes speichern i.d.R. Datentabellen. Dabei stehen in den Zeilen die Beobachtungen und in den Spalten die Variablen, die für die Beobachtungen gemessen wurden. Sie sind zweidimensionale Strukturen, die sich intern aus einer Menge gleichlanger Vektoren zusammen setzen. Eine Beispiel für eine dem Dataframe ähnliche Struktur ist eine Excel-Tabelle.
<br>
Die einfachste Möglichkeit einen Dataframes zu erzeugen ist die Funktion `data.frame()`. Eine Umwandlung anderer Datenstrukturen in einen Dataframe kann mit `as.data.frame()` getätigt werden, hierbei ist jedoch Vorsicht geboten, da Strukturen in den Daten verloren gehen können.
<br>
Um nachträglich Einträge zu einem Dataframe hinzuzufügen, können unter anderem `rbind()` [d.h. row bind, Zeile hinzufügen] und `cbind()` [d.h. column bind, Spalte hinzufügen] benutzt werden. 
<br>
```{r info_2_5, echo = TRUE}
# Erzeuge Beispielvektoren
vec_digits <- c(1, 2, 3, 4, 5)
vec_words <- c("eins", "zwei", "drei", "vier", "fünf")
vec_roman <- c("I", "II", "III", "IV", "V")

# Erzeuge einen Beispieldataframe aus den Vektoren
# Die einzelnen Spaltennamen werden dabei als characters übergeben 
numbers_df <- data.frame("digits" = vec_digits,
                         "words" = vec_words,
                         "roman" = vec_roman)

numbers_df

# Erzeuge ein weiteres Attribut mit 5 Werten
vec_english <- c("one", "two", "three", "four", "five")

# Füge das neue Attribut dem Dataframe hinzu
numbers_df_extended <- cbind(numbers_df, "english" = vec_english)
numbers_df_extended
```
Bei dem Hinzufügen von Attributen ist wichtig, dass das neue Attribut für jede Beobachtung im Dataframe einen Wert hat. Deshalb ist es nicht möglich dem Dataframe aus dem vorigen Beispiel einen `vec_english` mit weniger als 5 oder mehr als 5 Einträgen hinzuzufügen.
<br>
Darüber hinaus ist in dem Beispiel zu sehen, wie ein Dataframe von Natur aus mit characters umgeht: Sie werden in `factor`, also in Faktoren umgewandelt. Faktoren können dabei als Kategorien verstanden werden. Versucht man einen character hinzuzufügen, der keiner der bereits vorhandenen Kategorien angehört, erzeugt man fehlende Werte (siehe nächstes Beispiel).

```{r info_2_5_2, echo = TRUE}
# Erzeuge eine weitere Beobachtung
vec_6 <- c(6, "sechs", "VI", "six")

# Füge neue Beobachtung zum Dataframe hinzu
numbers_df_extended_6 <- rbind(numbers_df_extended, vec_6)
numbers_df_extended_6
```
<br>
Um dieses Problem zu Verhindern, kann man R mitteilen, dass characters nicht als factors interpretiert werden sollen. Dazu muss der Dataframe mit einem weiteren Parameter erzeugt werden.
```{r info_2_5_3, echo = TRUE}
# Erzeuge Beispielvektoren
vec_digits <- c(1, 2, 3, 4, 5)
vec_words <- c("eins", "zwei", "drei", "vier", "fünf")
vec_roman <- c("I", "II", "III", "IV", "V")

# Erzeuge einen Beispieldataframe aus den Vektoren
# Die einzelnen Spaltennamen werden dabei als characters übergeben 
numbers_df <- data.frame("digits" = vec_digits,
                         "words" = vec_words,
                         "roman" = vec_roman,
                         stringsAsFactors = FALSE) # durch diese Zeile werden characters beibehalten

# Erzeuge eine weitere Beobachtung
vec_6 <- c(6, "sechs", "VI")

# Füge neue Beobachtung zum Dataframe hinzu
numbers_df_6 <- rbind(numbers_df, vec_6)
numbers_df_6
```

<br>
Wie bereits erklärt wurde, werden die Zahlen in den Vektoren jedoch in `characters` umgewandelt. Wenn man mit den Zahlen weiter rechnen können möchte, muss man diese also zurückkonvertieren. Dies funktioniert folgenderweise:

```{r}
# Umwandeln der character Zahlen in Spalte 1 in integers
numbers_df_6[ , 1] <- as.integer(numbers_df_6[ , 1])
numbers_df_6
```


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## \ \ \ \ \ \ \ \ \ \ Übung 4: Dataframes

### Erzeugen und Erweitern von Dataframes
4.1) Erzeuge zwei Vektoren mit folgenden Daten: <br>
<ul>
<li>`t`: Mo, Di, Mi, Do, Fr, Sa </li>
<li>`m`: 92, 80, 60, 20, 10, 50 </li>
</ul>
Verbinde beide Vektoren spaltenweise zu einem Dataframe mit dem Namen `studie`. Vergib die Spaltennamen “Motivation”" für m und “Wochentag” für t.
```{r 4_1, exercise=TRUE}
t <- 
m <- 
 
studie <- 
studie
```
```{r 4_1-hint}
"Benutze die Funktion data.frame()."
```
```{r 4_1-solution}
t <- c("Mo","Di","Mi","Do","Fr","Sa")
m <- c( 92,  80,  60,  20,  10,  50)

studie <- data.frame(Motivation = m, Wochentag=t)
studie
```

4.2) Füge am unteren Ende von `studie` eine Zeile mit den Elementen "So" und 100 hinzu. Das Hinzufügen von Zeilen kann man z.B. bewerkstelligen, indem man einen einzeiligen Dataframe mit der gewünschten Zeile erstellt und diesen dann über rbind() mit dem usprünglichen Dataframe verbindet.
```{r 4_2_setup}
t = c("Mo","Di","Mi","Do","Fr","Sa") 
m = c( 92,  80,  60,  20,  10,  50)  

studie = data.frame(Motivation = m, Wochentag=t) 
```
```{r 4_2, exercise=TRUE, exercise.setup = "4_2_setup"}
studie <- 
studie
```
```{r 4_2-hint}
"Benutze die Funktion rbind()."
```
```{r 4_2-solution}
studie <- rbind(studie, data.frame(Motivation = 100, Wochentag = "So")) 
studie
```


### Laden und Sichten von Dataframes
Lade nun den vorgefertigten Datensatz `students.rdata` und wende die Funktion `summary(students)` an, um einen Überblick über den Datensatz zu erhalten. Beantworte anschließend die folgenden Fragen:
```{r 4_3_setup}
data("students", package = "geostat.tutorial")
```

```{r ausprobierbereich_4_1, exercise=TRUE, exercise.setup = "4_3_setup"}
# Hier können Befehle ausprobiert werden. Der Datensatz steht als Variable students zur Verfügung
students
```

4.3.) Wie groß ist der Stichprobenumfang `n`, d.h. wie viele Studierende haben an der Umfrage teilgenommen?
```{r 4_3, exercise=TRUE, exercise.setup = "4_3_setup"}
n <- 
n
```
```{r 4_3-hint-1}
"Benutze die Funktion nrow()."
```
```{r 4_3-hint-2}
# Befehl:
n <- nrow(students)
n
```
```{r 4_3-solution}
# Ergebnis:
n = 134
```

4.4) Wieviele Variablen wurden erfasst?
```{r 4_4, exercise=TRUE, exercise.setup = "4_3_4_setup"}
variables <- 
variables
```
```{r 4_4-hint-1}
"Benutze die Funktion ncol()."
```
```{r 4_4-hint-2}
# Befehl:
variables <- ncol(students)
variables
```
```{r 4_4-solution}
# Ergebnis:
variables = 8
```


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## 3. Statistische Eigenschaften
Als Programmiersprache für statistische Berechnungen und Analysen stellt R eine Vielzahl statistischer Kennwerte mit eingebauten Befehlen bereit. So bietet R, neben den aus Kapitel 1 bekannten Funktionen `min()`, `max()` und `sum()` eine Vielzahl weiterer Funktionen, die für Statistik notwendig sind.
<br>
Bevor diese thematisiert werden, ist es jedoch sinnvoll zunächst Skalenniveaus zu besprechen, da die Anwendbarkeit der Befehle vom Niveau der Zieldaten abhängig ist.

### 3.1 Skalenniveaus
Unterschiedliche Merkmale, die wir untersuchen, lassen unterschiedliche Operationen, Analysen, Visualisierungen, Interpretationen zu. Welche Möglichkeiten bestehen hängt dabei von den Eigenschaften der Merkmale ab. Eine wichtige Eigenschaft von Merkmalen ist ihr Skalenniveau, welches aus der Art des Merkmales und der Art seiner Messung resultiert.
<br>
Nach Stevens, S.S. (1946): On the Theory of Scales of Measurement. Science 103 (2684), gibt es 4 Skalenvieaus:

<ul>
<li>`nominal`:
  <ul>
    <li>Mögliche Ausprägungen sind Namen (oder Zahlen) ohne weitere Bedeutung, Ordnung oder Struktur</li>
    <li>Teilt Daten in Klassen</li>
    <li>Mögliche Operationen: =, ≠
    <li>Beispiele: Farben, Bodentypen</li>
 </ul>
</li>

<li>`ordinal`: 
  <ul>
    <li>Mögliche Ausprägungen sind Namen oder Zahlen, die eine implizite Ordnung haben</li>
    <li>Teilt Daten in Klassen, die geordnet werden können</li>
    <li>Mögliche Operationen: =, ≠, <, <=, >, >=</li>
    <li>Beispiele: Größen, Gewichte</li>
  </ul>
</li>

<li>`interval`:
  <ul>
    <li>Mögliche Ausprägungen sind Werte, mit denen sinnvoll Differenzen gebildet werden können</li>
    <li>Daten werden durch Zahlen repräsentiert</li>
    <li>Alle „benachbarten“ Werte sind gleich weit voneinander entfernt, Differenzbildung ist sinnvoll</li>
    <li>0 kann ein willkürlicher Wert sein</li>
    <li>Mögliche Operationen: =, ≠, <, <=, >, >=, +, -</li>
    <li>Beispiele: Grad Celsius, Grad Fahrenheit</li>
  </ul>
</li>

<li>`rational`:
  <ul>
    <li>Mögliche Ausprägungen sind Werte, mit denen sinnvoll Differenzen und zudem Anteile/Verhältnisse gebildet werden können (das beobachtete Phänomen hat einen absoluten, nicht-willkürlichen Nullpunkt)</li>
    <li>Daten werden durch Zahlen repräsentiert</li>
    <li>Jede statistische Operation hat eine Bedeutung</li>
    <li>0 ist kein willkürlicher Wert</li>
    <li>Mögliche Operationen: =, ≠, <, <=, >, >=, +, -, *, /</li>
    <li>Beispiel: Grad Kelvin</li>
  </ul>
</li>
</ul>

### 3.2 Lagemaße
Lagemaße oder auch Maße der zentralen Tendenz geben Auskunft über den üblichste oder häufigste Werte. Zu den Lagemaßen gehören:
<ul>
  <li>`mean(x)`: Arithmetisches Mittel der Werte</li>
  <li>`median(x)`: Der Wert, der größer ist als 50% aller Werte</li>
  <li>`quantile(x)`: Der Wert, unterhalb dessen ein bestimmter Anteil q der Daten liegt</li>
  <li>`Modus`: Der häufigste Wert; keine Funktion vorhanden</li>
</ul>

### 3.3 Streuungsmaße
Die zweite statistische Eigenschaft, die man sich ansieht, ist i.d.R. ein Maß der Streuung oder Variabiltät. Dies liefert eine ersten Eindruck von der Ausprägung der Unterschiede, die in den Daten vorhanden sind.
<br>
<b>Beachte</b>: Einige Streuungsmaße sind (sehr) anfällig für Ausreißer

<ul>
<li>`Spannweite`: Differenz zwischen dem größten und dem kleinsten Wert; keine direkte Funktion vorhanden (siehe `?range`)</li>
<li>`IQR(x)`: Interquartilsabstand, Differenz zwischen dem dritten Quartil (0.75-Quantil) und dem ersten Quartil (0.25-Quantil); nicht anfällig gegen Ausreißer</li>
<li>`var(x)`: Abweichung vom Mittelwert einer Stichprobe</li>
<li>`sd(x)`: die Wurzel der Varianz; hat daher wieder die gleiche Einheit wie die Messdaten </li>
</ul>

<br>
Die Werte können auf den folgenden Skalenniveaus berechnet werden. Ihre Bedeutung wird in der Vorlesung noch tiefergehend thematisiert.
```{r info_3_2}
no <- c("ja", "nein", "nein", "Liste aller Werte", "nein", "nein")
or <- c("ja", "ja", "nein", "vielleicht", "nein", "nein")
int <- c("ja, [wenn diskret, selten]", "ja", "ja", "ja", "ja", "ja")
rat <- c("ja, [wenn diskret, selten]", "ja", "ja", "ja", "ja", "ja")

names <- c("Modus", "Median", "Mitellwert", "Spannweite", "IQ-Abstand", "Varianz/SD")

niv_df <- data.frame(row.names = names, "nominal" = no, "ordinal" = or, "interval" = int, "rational" = rat)
kbl(niv_df[], escape = FALSE) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

### Beispiele:
```{r info_3_bsp, echo = TRUE}
vec <- c(0:100)

# Arithmetisches Mittel
mean_vec <- mean(vec)
mean_vec

# Median
median_vec <- median(vec)
median_vec

# Quantile
quantile_vec <- quantile(vec)
quantile_vec

# Spannweite
range_vec <- IQR(quantile_vec)
range_vec

# Interquartilsabstand
iqa_vec <- quantile_vec[4] - quantile_vec[2]
iqa_vec

#Varianz
var_vec <- var(vec)
var_vec

# Standardabweichung
sd_vec <- sd(vec)
sd_vec
```


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## \ \ \ \ \ \ \ \ \ \ Übung 5: Statistische Werte
Benutze für die folgende Übung den aus Übung 4 bekannten Datensatz `students`.

```{r 5_setup}
data("students", package = "geostat.tutorial")
```

5.1) Auf welchen Skalenniveaus liegen die folgenden Attribute vor?
```{r 5_1_, echo=FALSE}
quiz(caption = "\ ",
  question("Gender",
    answer("Nominal", correct = TRUE),
    answer("Ordinal"),
    answer("Intervall"),
    answer("Rational")
  ),
  question("EyeColor",
    answer("Nominal", correct = TRUE),
    answer("Ordinal"),
    answer("Intervall"),
    answer("Rational")
  ),
  question("Age",
    answer("Nominal"),
    answer("Ordinal"),
    answer("Intervall"),
    answer("Rational", correct = TRUE)
  ),
  question("Length",
    answer("Nominal"),
    answer("Ordinal"),
    answer("Intervall"),
    answer("Rational", correct = TRUE)
  ),
  question("Iam",
    answer("Nominal"),
    answer("Ordinal", correct = TRUE),
    answer("Intervall"),
    answer("Rational")
  ),
  question("Country",
    answer("Nominal", correct = TRUE),
    answer("Ordinal"),
    answer("Intervall"),
    answer("Rational")
  ),
  question("FieldOFStudies",
    answer("Nominal", correct = TRUE),
    answer("Ordinal"),
    answer("Intervall"),
    answer("Rational")
  ),
  question("Semester",
    answer("Nominal"),
    answer("Ordinal"),
    answer("Intervall"),
    answer("Rational", correct = TRUE)
  )
)
```

5.2) Berechne die Summe, den Durschnitt, den Median, das Minimum und das Maximum der Größe der Studierenden.
```{r 5_2, exercise=TRUE, exercise.setup = "5_setup"}

# Gesamte Größe der Studierenden im Datensatz
sum_length <- 

# Durchschnittliche Größe der Studierenden im Datensatz
mean_length <- 
  
# Median der Größe der Studierenden im Datensatz
median_length <- 

# Kleinste und größte Größe der Studierenden im Datensatz
min_length <- 
max_length <- 
  
  
sum_length
mean_length
median_length
min_length
max_length
```
```{r 5_2-hint-1}
# Befehle:
sum_length <- sum(students$Length)
mean_length <- mean(students$Length)
median_length <- median(students$Length)
min_length <- min(students$Length)
max_length <- max(students$Length)
```
```{r 5_2-solution}
# Ergebnisse:
sum_length = 23644.5
mean_length = 176.451
median_length = 177.5
min_length = 102
max_length = 203
```

5.3) Berechne nun auch den Interquantilsabstand, die Varianz und die Standardabweichung der Größe der Studierenden.
```{r 5_3, exercise=TRUE, exercise.setup = "4_setup"}

# Quantile der Größe der Studierenden im Datensatz
quantile_length <- 

# Interquartilsabstand der Größe der Studierenden im Datensatz
iqa_length <- 

# Varianz der Größe der Studierenden im Datensatz
var_length <- 

# Standardabweichung der Größe der Studierenden im Datensatz
sd_length <- 
  

quantile_length  
iqa_length
var_length
sd_length
```
```{r 5_3-hint-1}
# Befehle:
quantile_length <- quantile(students$Length)
iqa_length <- IQR(students$Length)
var_length <- var(students$Length)
sd_length <-  sd(students$Length)
```
```{r 5_3-solution}
# Ergebnisse:
quantile_length = c(102, 170, 178, 185, 203) 
iqa_length = 15
var_length = 164.706
sd_length = 12.834
```


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## 4. Plots
Plots in R werden mittels der Funktion `plot()` erzeugt (siehe auch `?plot`). Dabei wird eine Vielzahl von Parametern angeboten, die das Verhalten und die Darstellung des Plots beeinflussen, wie zum Beispiel: 
<br>
<ul>
<li>`x` und `y`: Daten, die geplottet werden sollen. `y` ist dabei häufig optional</li>
<li>`type`: Ändert das Darstellungsverhalten (z.B. Linie, Punkte, ...)</li>
<li>`main`: Überschrift des Plots</li>
<li>`sub`: Unterschrift des Plots</li>
<li>`xlab`: Beschriftung der X-Achse</li>
<li>`ylab`: Beschriftung der Y-Achse</li>
<li>`col`: Farbe der geplotteten Elemente</li>
</ul>
Wenn mehrere Elemente in einem Plot angezeigt werden sollen, darf die Funktion `plot` nur <b>einmal</b> aufgerufen werden. Weitere Punkte und Kurven können dann mittels `lines()` und `points()` hinzugefügt werden. Im folgenden werden einige Beispiele für Plots und ihre Erzeugung gezeigt. Beachte dabei die Einflüsse der Skalenviveaus auf die Darstellungsweise.
```{r info_4, echo = TRUE}

# Plotte die Größe der Studierenden
# Diese Daten liegen rationalskaliert vor
plot(
  x = students$Length,
  type = "o", # Type o plottet Linien und Punkte
  main = "Studierendengrößen in Zentimeter",
  xlab = "Studierenden ID",
  ylab = "Körpergröße [cm]",
  col = "blue"
)


# Plotte die Aufgenfarben der Studierenden
# Diese Daten sind nominalskaliert
plot(
  x = students$EyeColor,
  main = "Studierendenaugenfarben",
  xlab = "Faktorgruppe Farbe",
  ylab = "Anzahl der Studierenden in Faktorgruppe",
  col = "darkgreen"
  )


# Plotte das Alter der Studierenden
# Diese Daten liegen rationalskaliert vor
plot(
  x = students$Age,
  type = "p", # Type p Punkte
  main = "Studierendenalter in Jahren",
  xlab = "Studierenden ID",
  ylab = "Alter [Jahre]",
  col = "red"
)
# Füge Linie ein
lines(
  students$Age,
  col = "orange")
```



<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## \ \ \ \ Übung 6: Plots 
6.1) Wie man bei der Visualisierung der Variable `Age` gesehen hat, ist die Standardvisualisierung, die R für Daten wählt nicht immer optimal. Deshalb soll in dieser Aufgabe eine bessere Visualisierung gefunden werden. Das Ziel ist es die Hauptaltersgruppen der Studierenden zu finden, d.h. alle Altersklassen mit mehr als 10 Studierenden. Plotte eine entsprechende Visualisierung.
```{r 6_1, exercise=TRUE}

```
```{r 6_1-hint-1}
"Die Funktion table() könnte sich als hilfreich erweisen."
```
```{r 6_1-hint-2}
"Betrachte die Funktion barchart()."
```
```{r 6_1-hint-3}
"Die Funktion abline() kann horizontale Linien erzeugen."
```
```{r 6_1-solution}
counts <- table(students$Age)

barplot(
  counts,
  main = "Hauptaltersgruppen der Studierenden",
  xlab = "Alter [Jahre]", 
  ylab = "Anzahl der Studierenden")

abline(h = 10, col = "red")
```

6.2) Erzeuge einen Vektor `x` von -3 bis 3 in 0.1-Schritten. Zeichne die Funktionen $y=x^2$, $y=1−x^2$ und $y=5+x^2$. 
```{r 6_2, exercise=TRUE}
x <- 
y1 <- 
y2 <- 
y3 <- 
  
plot()
...
...
```
```{r 6_2-hint-1}
"Portenzen in R werden mit ^ eingegeben. Beispiel: 2^2 = 4"
```
```{r 6_2-hint-2}
"Denke daran, plot() nur einmal aufzurufen."
```
```{r 6_2-solution}
x <- seq(-3, 3, by = 0.1)
y1 <- x ^ 2
y2 <- 1 - x^2
y3 <- 5 + x^2

plot(x, y1, ylim = c(-10, 20), type = "l", col = "orange",
     xlab = "x", ylab = "y", main = "Parabeln")
lines(x, y2, col = "purple")
lines(x, y3, col = "darkgreen")
```
```{r 6_2_q, echo=FALSE}
quiz(caption = "\ ",
     
  question("Welche Veränderung kannst du in der Matrix beobachten? (Mehrfachauswahl möglich)",
           
    answer("y1 hat ein Minimum von 5"),
    answer("y2 hat ein Minimum von 5"),
    answer("y3 hat ein Minimum von 5", correct = TRUE),
    
    answer("y1 entspricht der Normalparabel", correct = TRUE),
    answer("y2 entspricht der Normalparabel"),
    answer("y3 entspricht der Normalparabel"),
    
    answer("y1 entspricht einer invertierten Normalparabel"),
    answer("y2 entspricht einer invertierten Normalparabel", correct = TRUE),
    answer("y3 entspricht einer invertierten Normalparabel")
  )
)
```


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## 5. Erweiterte Konzepte

### 5.1 Pakete
Um den Funktionsumfang von R zu erweitern können werden Pakete verwendet. Diese bündeln Funktionen, die R erweitern thematisch. So wird im Laufe der Übung beispielsweise das Paket `sp` benötigt um besser mit räumlichen Daten arbeiten zu können. `ggplot` hingegen ist ein bekanntes Paket, dass die Möglichkeit bietet bessere Plots zu erzeugen. Auch dieses Tutorial wurde mit einem R Package, `learnr`, erzeugt. Aufgrund dieser vielseitigen Optionen ist es wichtig Pakete nutzen zu können.
<br>
Um ein Paket zu installieren muss der Befehl `install.packages("Paketname")` genutzt werden. Beispielsweise wird mit  `install.packages("sp")` das Paket `sp` installiert.
<br>
Um das Paket dann nutzen zu können, muss das Paket eingebunden werden. Dies geschieht mittels `library(Paketname)` und muss bei jedem Neustart von R wiederholt werden. Um `sp` einzubinden muss also `library(sp)` eingegeben werden. Daraufhin stehen die bereitgestellten Funktionen zur Verfügung.
<br>
Bei manchen Paketen kann es vorkommen, dass Funktionsnamen sich überlappen. Beispielweise haben sowohl `pkg_1` als auch `pkg_2` eine Funktion namens `mean()`. Dann kann mittels der folgenden Notation gewählt werden, welche Funktion genutzt wird: `pkg_2::mean()`.

### 5.2 Der Umgang mit NAs
Bisher waren die Daten im Bezug auf die Aufgaben grundsätzlich "perfekt", d.h. vollständig und fehlerfrei. Bei Datensätzen aus der realen Welt, wie z.B. dem `students`-Datensatz, besteht jedoch das Problem, dass diese nicht immer perfekt sind. Fehlende oder fehlerhafte Werte führen häufig zu Schwierigkeiten bei der Datenanalyse, wenn sie nicht richtig behandelt werden. Insbesondere fehlende Werte, in R durch `NA` repräsentiert, beeinflussen die Analyse stark. Sie können dafür sorgen, dass Funktionen gar nicht oder nur fehlerhaft ausgeführt werden. Daher ist es wichtig Datensätze zu prüfen. `NAs` können relativ leicht identifiziert werden. Mit `any(is.na(DATAFRAMENAME))` wird überprüft, ob der gesamte Dataframe `NAs` beinhaltet. Auch einzelne Spalten können getestet werden, wie z.B. `any(is.na(students$Semester))`. 
```{r NA, include = TRUE, echo = TRUE}
# Untersuche students auf NAs
any(is.na(students))

# Da stundents NAs aufweist, müssen die betroffenen Attribute identifiziert werden
any(is.na(students$Length)) # --> keine fehlenden Attribute
any(is.na(students$Semester)) # --> fehlende Attribute
```

In den Daten zur Größe fehlen also keine Daten, in der Semesteranzahl hingegen schon. Die Auswirkungen auf simple Funktionen werden im folgenden Beispiel deutlich:
```{r NA_mean, include = TRUE, echo = TRUE}
# Keine fehlenden Attribute/NAs
mean(students$Length) 

# Fehlende Attribute/NAs
mean(students$Semester) 
```
<br>
Es gibt verschiedene Möglichkeiten mit `NAs` umzugehen. Sie können durch Platzhalterwerte ersetzt, aufgefüllt oder ausgelassen werden. Welche der Methoden sinnvoller ist liegt dabei im Ermessen der/s Analysierenden und ist von Fall zu Fall unterschiedlich. In den folgenden Beispielen werden einige Möglichkeiten gezeigt.

```{r NA_replace_99, include = TRUE, echo = TRUE}
# Fehlende Attribute/NAs
any(is.na(students$Semester))

# Erzeuge temporäre Variable students_filled_99, um students nicht zu überschreiben
students_filled_99 <- students

# Ersetze alle NAs in der Spalte "Semester" durch PLatzhalter 99
students_filled_99$Semester[is.na(students_filled_99$Semester)] <- 99
```

```{r NA_replace_mean, include = TRUE, echo = TRUE}
# Fehlende Attribute/NAs
any(is.na(students$Semester))

# Erzeuge temporäre Variable students_filled_mean, um students nicht zu überschreiben
students_filled_mean <- students

# Berechne Durschnittswert mit Auslassen von NAs
mean_age <- mean(students$Semester, na.rm = TRUE)

# Ersetze alle NAs in der Spalte "Semester" durch 99
students_filled_mean$Semester[is.na(students_filled_mean$Semester)] <- mean_age
```

```{r leave_out, include = TRUE, echo = TRUE}
# Entferne die Beobachtung mit dem NA ganz aus dem Datensatz
# Erzeuge hierfür neuen data.frame und übernehme nur die Zeilen aus dem students data.frame,
## die keine NAs (!is.na()) in der Spalte "Semester" haben
students_NA_removed <- students[!is.na(students$Semester), ]

# Teste auf NAs:
any(is.na(students_filled_99$Semester))
any(is.na(students_filled_mean$Semester))
any(is.na(students_NA_removed))


# Berechne Durchschnitte NA
mean(students_filled_99$Semester)
mean(students_filled_mean$Semester)
mean(students_NA_removed$Semester)
```
Durch diese drei Beispiele zum Umgang mit `NAs` wird deutlich, dass verschiedene Ziele verschiedene Ansätze benötigen. So bietet das ersetzen mit einem Ausreißerwert den Vorteil, dass vorher fehlende Werte immer noch identifziert werden können, aber Berechnungen, wenn auch beeinflusst, möglich sind. Das Auffüllen mit einem Durschnittswert hat den Vorteil, dass keine Beobachtungen verloren gehen und Berechnungen möglich sind, kann jedoch auch Verhältnisse in den Daten verzerren. Das Auslassen von Beobachtungen mit `NAs` hat den großen Vorteil, dass keine Annahmen getroffen werden müssen, d.h. aller Ergebnisse immer nachvollziehbar sind. Der deutliche Nachteil dabei ist jedoch, dass Beobachtungen verloren gehen.
<br>

Wie bereits zu sehen war, besitzen einige Funktionen spezielle Parameter, mit denen angegeben werden kann, was mit NAs zu tun ist. So kann zum Beispiel der Funktion `mean` über den Parameter `na.rm = TRUE` übergeben werden, dass NAs vor der Berechnung des Mittelwertes aus den Daten entfernt werden sollen.
Der Datensatz selbst wird dabei nicht verändert:

```{r NA_skip, include = TRUE, echo = TRUE}
# Auslassen von NAs durch Parameter. Ergebnis entspricht dem des Befehls mean(students_NA_removed$Semester) nach Entfernen der Beobachtung, die NA enthielt.
# Hier bleibt der students-Datensatz selbst jedoch unverändert
mean(students$Semester, na.rm = TRUE)
```


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


### 5.3 Datenmanagement
Nachdem nun der Umgang mit Daten innerhalb von R erläutert wurde, stellt sich die Frage, wie sie in R importiert und aus R heraus exportiert werden können. Um dies zu erleichtern bietet es sich an, eine strukturierte Datenhaltung anzuwenden. Darum wird diese hier auch thematisiert.

#### Geostatistik Ordner
Im Verlauf der Übung zu diesem Kurs werden verschiedene Datensätze zur Verfügung gestellt. Erfahrungsgemäß ist der Import dieser Daten eine der größten Schwierigkeiten für Studierende und eine der häufigsten Fehlerquellen. Um diese Schwierigkeiten zu umgehen sollten alle Datensätze an einem leicht erreichbaren Ort gespeichert werden. Dazu bietet sich zum Beispiel der Desktop an. Dort kann dann ein Ordner angelegt werden mit dem Namen `Geostatistik`. In diesem werden dann die Datenstäze gespeichert. Dafür kann auch ein Unterordner, z.B. `Daten`, angelegt werden.

#### Datenimport
Der Import von Daten besteht aus zwei Bestandteilen: Einem Dateiformat-spezifischen Befehl und einem Pfad. In der Übung werden die Datenformate `.rdata` und `.txt`. Die Befehle um diese Formate zu importieren sind:

<ul>
  <li>`.rdata`:
  <br>
      Wird mit `load(PFAD)` geladen. 
      <br>
      Beispiel: `load("C:/Users/Beispieluser/Desktop/Geostatistik/Daten/Daten_1.rdata"`
  </li>
  
  <li>`.txt`:
  <br>
      Wird mit `read.delim(PFAD)`oder `read.delim2(PFAD)` geladen, je nach Dezimalzeichen. 
      <br>
      Beispiel: `data <- read.delim("C:/Users/Beispieluser/Desktop/Geostatistik/Daten/Daten_1.txt"`
  </li>
  
  <li>`.csv`:
  <br>
      Wird mit `read.cvs` geladen.
      <br>
      Beispiel: `data <- read.csv("C:/Users/Beispieluser/Desktop/Geostatistik/Daten/Daten_1.csv"`
  </li>
</ul>

<br>
Der Pfad "zeigt" dabei auf den Speicherort der Datei. Das Format und Teile davon sind dabei abhängig vom Betriebssystem des Computers. Wenn die vorgeschlagene Dateistruktur genutzt wird, können die folgenden Pfade benutzt werden. Dabei muss `username` durch den Benutzernamen des aktuellen Kontos ersetzt werden. Es ist wichtig, dass der Pfad weder Leerzeichen noch Umlaute enthält, da diese oft zu Fehlern führen.

<ul>
<li>Mac: `"/Users/username/Desktop/Geostatistik/Daten/..."`</li>
<li>Linux: `"/home/username/Desktop/Geostatistik/Daten/..."`</li>
<li>Windows: `"C:/Users/username/Desktop/Geostatistik/Daten/..."`</li>
</ul>

#### Datenexport
in R manipulierte Daten können in Dateien verschiedenster Typen gespeichert, verteilt und wieder in R eingelesen werden. Dazu werden ebenfalls ein Befehl und ein Pfad benötigt. Die Befehle für die hier verwendeten Datentypen sind die folgenden:

<ul>
<li>`.rdata` wird mit `save(Objekt, Pfad)` gespeichert</li>
<li>`.txt` wird mit `write.table(Objeckt, file = Pfad, ...)` gespeichert</li>
<li>`.csv` wird mit `write.csv(Objekt, Pfad)` gespeichert</li>
</ul>
         
         
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


### 5.4 Übergang zu RStudio
```{r img_5.4, out.width = "100%"}
knitr::include_graphics("images/overview.png")
```
<br><br>
Nachdem nun alle inhaltlichen Teile der Einführung in R abgehandelt sind, kann die geschützte Umgebung verlassen werden. Zur Erleichterung des Umstiegs wird hier das Interface von RStudio kurz erklärt. Das Fenster von RStudio ist in 4 Bereiche aufgeteilt, jeder mit seinen eigenen, wichtigen Funktionen. Bei diesen Bereichen handelt es sich um:

#### Skriptbereich
Hier werden geöffnete Skripte und Markdown-Dateien angezeigt. Dieser Bereich ist vergleichbar mit den Eingabefeldern für Code, die im Tutorial angezeigt werden. Hier werden Befehle gesammelt, organisiert und ausgeführt.
<br>
Um Code von hier auszuführen kann man entweder die kleinen grünen Pfeile in der oberen, rechten Ecke des markierten Bereichs (Chunk) anklicken, den Code markieren und Strg+Enter drücken, oder den Code von Hand in die Konsole kopieren. Eine weitere Möglichkeit ist es, am oberen Rand des Bereichs den Run-Knopf zu drücken. Dieser führt bietet verschiedene Ausführungsoptionen, z.B. das ganze Skript oder nur den gewählten Bereich.

#### Konsolenbereich
Der Konsolenbereich kann genutzt werden, um Befehle direkt auszuführen. Dies eignet sich zum Beispiel für Befehle die nicht wiederholt werden müssen und zum Ausprobieren. Befehle die vorher ausgeführt wurden können hier mit den Pfeiltasten wiederhergestellt werden.

#### Arbeitsbereich
Im Arbeitsbereich werden die verfügbaren Daten, Werte, Variablen und selbsterstellte Funktionen angezeigt. Dies dient vor allem zur Übersicht. Wenn sich neben den Namen von Daten ein blauer Kreis mit einem weißen Pfeil befindet, kann dieser angeklickt werden um detaillierte Informationen auszuklappen. Mit Klicken auf das Tabellensymbol rechts neben den Namen wird eine tabellarische Ansicht der Daten geöffnet.
<br>
Darüber hinaus kann hier auch der Verlauf der Eingaben in der Konsole angezeigt werden. Nutze dazu den Reiter "History"

#### Outputbereich
Im Outputbereich werden Plots, Hilfen und Dateien angezeigt.


<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->
<!--------------------------------------------------------------------------------->


## Literatur

Weitere nützliche Quellen zum Einstieg in R und zum Nachschlagen sind z.B:
<br>
[1] [Ausfürliches, weiterführendes, deutsches Skript von Dr. Gerrit Eichner](https://www.uni-giessen.de/fbz/fb07/fachgebiete/mathematik/mathematik/ags/stoch/personen/wimis/eichner/skriptenfiles/r1sum16.r4win17)
<br>
[2] [Advanced R by Hadley Wickham, begleitende Website, englisch](http://adv-r.had.co.nz)
<br>
[3] [Efficient R programming, weiterführendes Buch über effiziente Programmierung in R, englisch](https://csgillespie.github.io/efficientR/index.html)
<br>
[4] [R Cheat Sheets](https://rstudio.com/resources/cheatsheets/)
